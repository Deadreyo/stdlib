/*
* @license Apache-2.0
*
* Copyright (c) 2024 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

// TypeScript Version: 4.1

/**
* Interface defining function options.
*/
interface Options {
	/**
	* The maximum number of pending invocations at any one time.
	*/
	limit?: number;

	/**
	* Execution context.
	*/
	thisArg?: any;
}

/**
* Callback invoked upon completion.
*/
type DoneNullary = () => void;

/**
* Callback invoked upon completion.
*
* @param error - encountered error or null
*/
type DoneUnary = ( error: Error ) => void;

/**
* Callback invoked upon completion.
*
* @param error - encountered error or null
* @param out - output object
*/
type DoneBinary<T> = ( error: Error | null, out: Array<T> ) => void;

/**
* Callback invoked upon completion.
*
* @param error - encountered error or null
*/
type DoneCallback<T> = DoneNullary | DoneUnary | DoneBinary<T>;

/**
* Execute functions in parallel, passing the results of all functions to a final callback.
*/
type ParallelFunction = () => void;

/**
* Interface for `parallel`.
*/
interface Parallel {
	/**
	* Executes a set of functions in parallel.
	*
	* @param fcns - array of functions
	* @param options - function options
	* @param options.thisArg - function context
	* @param options.limit - number of functions to execute concurrently
	* @param clbk - callback to invoke upon completion
	*
	* @example
	* var parallel = require( '@stdlib/utils/async/parallel' );
	*
	* function foo( resolve ) {
	*     setTimeout( onTimeout, 300 );
	*     function onTimeout() {
	*         resolve( null, 'one' );
	*     }
	* }
	*
	* function bar( resolve ) {
	*     setTimeout( onTimeout, 100 );
	*     function onTimeout() {
	*         resolve( null, 'two' );
	*     }
	* }
	*
	* function done( error, results ) {
	*     if ( error ) {
	*         throw error;
	*     }
	*     console.log( results );
	*     // => [ 'one', 'two' ]
	* }
	*
	* var fcns = [ foo, bar ];
	*
	* var opts = {
	* 	'thisArg': {},
	* 	'limit': 2
	* }
	*
	* parallel( fcns, opts, done );
	*/
	<T = unknown>( fcns: ArrayLike<Function>, options: Options, clbk: DoneCallback<T> ): void;

	/**
	* Executes a set of functions in parallel.
	*
	* @param fcns - array of functions
	* @param clbk - callback to invoke upon completion
	*
	* @example
	* var parallel = require( '@stdlib/utils/async/parallel' );
	*
	* function foo( resolve ) {
	*     setTimeout( onTimeout, 300 );
	*     function onTimeout() {
	*         resolve( null, 'one' );
	*     }
	* }
	*
	* function bar( resolve ) {
	*     setTimeout( onTimeout, 100 );
	*     function onTimeout() {
	*         resolve( null, 'two' );
	*     }
	* }
	*
	* function done( error, results ) {
	*     if ( error ) {
	*         throw error;
	*     }
	*     console.log( results );
	*     // => [ 'one', 'two' ]
	* }
	*
	* var fcns = [ foo, bar ];
	*
	* parallel( fcns, done );
	*/
	<T = unknown>( fcns: ArrayLike<Function>, clbk: DoneCallback<T> ): void;

	/**
	* Returns a reusable parallel function.
	*
	* @param fcns - array of functions
	* @param options - function options
	* @param options.thisArg - function context
	* @param options.limit - number of functions to execute concurrently
	* @param clbk - callback to invoke upon completion
	* @returns parallel function
	*
	* @example
	* function a( resolve ) {
	*     setTimeout( onTimeout, 0 );
	*     function onTimeout() {
	*         resolve( null, 2 );
	*     }
	* }
	*
	* function b( resolve ) {
	*     setTimeout( onTimeout, 0 );
	*     function onTimeout() {
	*         resolve( null, 4 );
	*     }
	* }
	*
	* function done( error, out ) {
	*     if ( error ) {
	*         throw error;
	*     }
	*     console.log( out );
	*     // => [ 2, 4 ]
	* }
	*
	* var fcns = [ a, b ];
	*
	* var opts = {
	* 	'thisArg': {},
	* 	'limit': 2
	* }
	*
	* var run = parallel.factory( fcns, opts, done );
	*
	* run();
	*/
	factory<T = unknown>( fcns: ArrayLike<Function>, options: Options, clbk: DoneCallback<T> ): ParallelFunction;

	/**
	* Returns a reusable parallel function.
	*
	* @param fcns - array of functions
	* @param clbk - callback to invoke upon completion
	* @returns parallel function
	*
	* @example
	* function a( resolve ) {
	*     setTimeout( onTimeout, 0 );
	*     function onTimeout() {
	*         resolve( null, 2 );
	*     }
	* }
	*
	* function b( resolve ) {
	*     setTimeout( onTimeout, 0 );
	*     function onTimeout() {
	*         resolve( null, 4 );
	*     }
	* }
	*
	* function done( error, out ) {
	*     if ( error ) {
	*         throw error;
	*     }
	*     console.log( out );
	*     // => [ 2, 4 ]
	* }
	*
	* var fcns = [ a, b ];
	*
	* var run = parallel.factory( fcns, done );
	*
	* run();
	*/
	factory<T = unknown>( fcns: ArrayLike<Function>, clbk: DoneCallback<T> ): ParallelFunction;
}

/**
* Execute functions in parallel, passing the results of all functions to a final callback.
*
* @param fcns - array of functions
* @param options - function options
* @param options.thisArg - function context
* @param options.limit - number of functions to execute concurrently
* @param clbk - callback to invoke upon completion
*
* @example
* var parallel = require( '@stdlib/utils/async/parallel' );
*
* function foo( resolve ) {
*     setTimeout( onTimeout, 300 );
*     function onTimeout() {
*         resolve( null, 'one' );
*     }
* }
*
* function bar( resolve ) {
*     setTimeout( onTimeout, 100 );
*     function onTimeout() {
*         resolve( null, 'two' );
*     }
* }
*
* function done( error, results ) {
*     if ( error ) {
*         throw error;
*     }
*     console.log( results );
*     // => [ 'one', 'two' ]
* }
*
* var fcns = [ foo, bar ];
*
* parallel( fcns, done );
*/
declare var parallel: Parallel;


// EXPORTS //

export = parallel;
